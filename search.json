[{"title":"心流-营造最优工作体验","date":"2018-09-29T04:09:43.000Z","url":"/2018/09/29/%E5%BF%83%E6%B5%81-%E8%90%A5%E9%80%A0%E6%9C%80%E4%BC%98%E5%B7%A5%E4%BD%9C%E4%BD%93%E9%AA%8C/","tags":["thinking"],"content":"幸福的体验近些年发展起来的积极心理学研究的是如何让人们生活的更加快乐和幸福，经过对生活状态幸福的人长时间的跟踪研究，它把幸福的体验分为三种。快乐的人生、有意义的人生、积极参与的人生。 第一种指的就是传统意义上的快乐情绪，这种体验通常是一种积极的情感，考试考了高分、升职、尝到了期待已久的美食，当下都会一种开心的感觉。但这种感觉一般不会持续很久，属于最低层次的幸福感。 第二种是能够利用自己最大的优势在比自我更大的事业中找到归属感。 第三种即为心流。 根据研究数据显示，第一种基本不影响我们对人生的满意度，而第二种、第三种可以很大程度提升我们对于人生的满意度即幸福的体验。 何为心流“心流”是指我们在做某些事情时，那种全神贯注、投入忘我的状态——这种状态下，你甚至感觉不到时间的存在，在这件事情完成之后我们会有一种充满能量并且非常满足的感受。其实很多时候我们在做自己非常喜欢、有挑战并且擅长的事情的时候，就很容易体验到心流，比如爬山、游泳、打球、玩游戏、阅读、演奏乐器还有工作的时候。 用心流营造工作体验曾有人向弗洛伊德讨教快乐的秘诀，他给出的答案简单而明白：工作与爱。如果能够在工作中找到心流，不仅可以提高效率还可以增强工作生活的幸福感。 工作可以残酷而无聊，但也可以充满乐趣和刺激。 在互联网行业，大家的工作时间都在八个小时以上，基本上占据了自己一半以上的清醒时间。如果这个时间段的工作体验非常差的话，整个人在生活中的幸福感也会降低。 在工作有难度或者感觉到枯燥的时候，如果自己可以专注应对，形成一种完成挑战的状态，不仅可以让自己的能力得到更好的提升，也可让自己长时间的保持这种状态。这种专注应对挑战的状态本身就是最优的体验。在工作中，如果陷入了糟糕的工作体验，不妨重新设计工作方法，让自己重获最优体验。 明确目标。如果遇到了一些十分乏味缺乏挑战的工作，不妨给自己制定一个标准和具体目标，比如简单的重复业务，那么可以每次做的时候想一下有没有比上次实现更快更优雅的做法。给自己的脑子树立一个靶子，让自己的大脑对原本无聊的工作因为聚焦产生兴趣。 增加挑战。如果在工作中的挑战太过于简单，则可以给自己的工作设置必要的难度标准，既不能难度过低，也不能让自己无从下手。 及时反馈。在参与多人协同的大型项目中，有时候不容易获得及时的正向反馈，项目上线了，不知道自己的工作在其中起到了多大的作用。这时候可以跟产品要到项目的实际效果数据，比如说页面的 pv、uv、成交量等等，得到正反馈。 做到以上三点，可以让我们更容易进入心流状态，提升自己工作的品质。"},{"title":"函数式编程初探","date":"2018-09-28T04:09:43.000Z","url":"/2018/09/28/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%88%9D%E6%8E%A2/","tags":["JS"],"content":"什么是函数式编程函数式编程是一种编程思想或者说编程泛型，经典的命令式编程模型强调指令的执行，而函数式强调函数计算本身，主要思想是把运算过程尽量编写为一系列嵌套的函数调用。 举个例子： 可以看到命令式编程的特点是把每一个运算当做一个步骤来执行，通过步骤的组合最后得到结果。而函数式编程则把运算用函数来体现，通过函数的组合来得到运算结果。 函数式编程的特征一等公民的函数函数与其他的数据类型一样，是平等的，可以赋值给其他变量或者作为参数传递，以及作为其他函数的返回值，如下例中的 increase 纯函数纯函数是这样一种函数，即相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用。副作用是指函数的内部与外部互动，比如说修改全局变量的值，产生运算外的其他结果。函数式编程强调没有副作用，函数要保持独立，所有的功能就是返回一个新的值而没有其他的行为。 比如 slice 和 splice，slice 对于相同的输入能保证返回相同的输出，因此它是纯函数。而 splice 会改变调用它的数组，这就会产生可观察的副作用，数组永久的改变了。 用表达式代替语句表达式是一个单纯的运算并且总是有返回值，语句是执行某一操作，没有返回值。函数式编程要求只使用表达式不用语句，也就是每一步都是单纯运算并且有返回值。 不修改状态函数式编程只是返回新的值，不修改系统的变量。 在一般的语言中，变量用来保存状态，不修改变量意味着状态不能被保存在变量中。 函数式编程用参数来保存状态。 上面是一个用来反转字符串的递归函数，注意到它并没有使用变量来保存状态，而是使用参数来进行传递。 并且它的最后一步是调用自身函数，这就是尾递归。尾调用在函数式编程中非常重要。因为递归在本质上是一种循环操作。纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现，使用递归最好使用尾递归。(在浏览器层面目前仅 safari 支持，chrome 的 V8 默认关闭尾递归优化功能，因为尾调用优化有隐式优化和调用栈丢失的问题)。 为什么要使用函数式编程开发效率函数式编程使用了大量的函数，减少了代码的重复，开发效率快。更容易和代码的模块化结合起来，方便管理和扩展。函数式编程不依赖和改变外界的状态，只要给定输入参数必然会返回相同的结果。因此每个函数都可以看做是独立的单元，有利于编写单元测试和调试。扩展时也只需要增加对应的运算函数即可。 可读性高函数式编程可以使用链式调用的写法 易读性强的代码就是最好的注释，能非常直观的表达含义，配合类型签名(type signatures)能够表露函数的行为和目的。 并发编程函数式编程是不会产生死锁的，因为它不会修改变量，所以不存在锁线程的问题。不用担心一个线程的数据被另一个线程修改，所以可以很安全的在多个线程上运行不同的任务，部署并发编程。 action1 和 action2 互不干扰，执行的先后顺序并不会影响最终结果，所以可以把它们分配在两个线程上完成。而在一般的编程模式中，action1 可能会修改系统状态，而 action2 可能会用到这些状态，所以必须保证 action2 在 action1 后面执行，也就不能在其他线程上运行了。 参考资料 函数式编程离我们有多远 什么是函数式编程思维 JS 函数式编程指南 "},{"title":"GraphQL初探","date":"2018-07-03T04:09:43.000Z","url":"/2018/07/03/GraphQL%E5%88%9D%E6%8E%A2/","tags":["JS"],"content":"什么是 GraphQLGraphQL 既是一种用于 API 的查询语言也是一个满足你数据查询的运行时。 GraphQL 对你的 API 中的数据提供了一套易于理解的完整描述，使得客户端能够准确地获得它需要的数据，而且没有任何冗余，也让 API 更容易地随着时间推移而演进，还能用于构建强大的开发者工具。 一个简单的例子 GraphQL 的特征 可描述性的：使用 GraphQL，你获取的都是你想要的数据，不多也不会少 分级性的：GraphQL 天然遵循对象间的关系，通过一个简单的请求，我们可以获取到一个对象及其相关的对象，比如说，通过一个简单的请求，我们可以获取一个作者和他创建的所有文章，然后可以获取文章的所有评论 强类型的：使用 GraphQL 的类型系统，我们可以描述能够被服务器查询的可能的数据，然后确保从服务器获取到的数据和我们查询的一致 不做语言限制：并不绑定于某一特定的语言，实际上现在已经有一些不同的语言有了实践； 兼容于任何后台：GraphQL 不限于某一特定数据库，可以使用已经存在的数据，代码，甚至可以连接第三方的 APIs 好反省的：GraphQL 服务器能够查询架构的细节 Type对于数据模型的抽象是通过 Type 来描述的，每一个 Type 有若干 Field 组成，每个 Field 又分别指向某个 Type。 GraphQL 的 Type 简单可以分为两种，一种叫做 Scalar Type(标量类型)，另一种叫做 Object Type(对象类型)。 Scalar TypeGraphQL 中的内建的标量包含，String、Int、Float、Boolean、Enum，可以通过 Scalar 声明一个新的标量，标量是 GraphQL 类型系统中最小的颗粒。 Object Type对象类型用来抽象一些复杂的数据模型 Type Modifier类型修饰符有两种，分别是 List 和 Required ，它们的语法分别为[Type]和 Type!, 同时这两者可以互相组合，比如[Type]!或者[Type!]或者[Type!]!，它们的含义分别为： 列表本身为必填项，但其内部元素可以为空 列表本身可以为空，但是其内部元素为必填 列表本身和内部元素均为必填 SchemaSchema 是用来描述对于接口获取数据逻辑的，我们不妨把它当做 REST 架构中每个独立资源的 uri 来理解它，只不过在 GraphQL 中，我们用 Query 来描述资源的获取方式。因此，我们可以将 Schema 理解为多个 Query 组成的一张表。 Query下面三种基本查询类型是作为 Root Query（根查询）存在的，对于传统的 CRUD 项目，我们只需要前两种类型就足够了，第三种是针对当前日趋流行的 real-time 应用提出的。 我们按照字面意思来理解它们就好，如下： query（查询）：当获取数据时，应当选取 Query 类型 mutation（更改）：当尝试修改数据时，应当使用 mutation 类型 subscription（订阅）：当希望数据更改时，可以进行消息推送，使用 subscription 类型 以 REST 和 GraphQL 的角度举例： Rest 接口 GraphQL Query ResolverResolver（解析函数）用来提供相关 Query 所返回数据的逻辑。GraphQL 中，Query 和与之对应的 Resolver 是同名的。 Resolver 本身的声明在各个语言中是不一样的，因为它代表数据获取的具体逻辑。它的函数签名(以 js 为例子)如下： 其中的参数的意义如下： parent: 当前上一个 Resolver 的返回值 args: 传入某个 Query 中的函数（比如上面例子中 article(id: Int)中的 id） ctx: 在 Resolver 解析链中不断传递的中间变量（类似中间件架构中的 context） info: 当前 Query 的 AST 对象 Resolver 内部实现对于 GraphQL 完全是黑盒状态。这意味着 Resolver 如何返回数据、返回什么样的数据、从哪返回数据，完全取决于 Resolver 本身，基于这一点，在实际中，往往把 GraphQL 作为一个中间层来使用，数据的获取通过 Resolver 来封装，内部数据获取的实现可能基于 RPC、REST、WS、SQL 等多种不同的方式。同时，在对一些未使用 GraphQL 的系统进行迁移时（比如 REST），可以很好的进行增量式迁移。 优点 网络开销低，可以在单一请求中获取 REST 中使用多条请求获取的资源 强类型 Schema（约束意味着可以根据规范形成文档、IDE、错误提示等生态工具） 特别适合图状数据结构的业务场景（比如好友、流程、组织架构等系统） 缺点 本身的语法相比较 REST 和 RPC 均复杂一些 实现方面需要配套 Caching 以解决性能瓶颈 对于 API 的版本控制当前没有完善解决方案（社区的建议是不要使 API 版本化） 仍然是新鲜事物，很多技术细节仍然处于待验证状态 参考资料 GraphQL RPC vs REST vs GraphQL 一篇文章帮你理清 GraphQL 的核心概念（译） GraphQL 规范 "},{"title":"如何实现一个Promise","date":"2018-07-02T04:09:43.000Z","url":"/2018/07/02/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAPromise/","tags":["JS"],"content":"Promise 是什么Promise 是异步编程的一种解决方案，比传统的回调函数和事件更加合理易用。它是一个容器，里面保存着某个未来才会结束的事件的结果，也是一个可以获取异步操作消息的对象。举个例子，如果想要使用 Promise API 异步调用一个远程的服务器，需要创建一个代表数据将会在未来由 Web 服务返回的 Promise 对象，目前数据还不可用，当请求完成并从服务器返回时数据将变为可用数据，在这个过程中，Promise 对象扮演一个数据的代理角色。在 Promise 对象上绑定一个回调函数，数据变得可用时这个回调函数将会被调用。 Promises&#x2F;A+规范Promise 是一个拥有 then 方法的对象或函数，并且其当前状态必须为一下三种状态中的一种：等待态（Pending）、执行态（Fulfilled）和拒绝态（Rejected）。 等待态（Pending）：可以迁移至执行态或拒绝态 执行态（Fulfilled）：不能迁移至其他任何状态，必须拥有一个不可变的终值 拒绝态（Rejected）：不能迁移至其他任何状态，必须拥有一个不可变的拒绝原因 一个 Promise 必须提供一个 then 方法以访问其当前值、终值和拒绝原因。 Promise 的 then 方法接收两个参数： onFulfilled 和 onRejected 都是可选参数。 如果 onFulfilled 不是函数，其必须被忽略 如果 onRejected 不是函数，其必须被忽略 onFulfilled 特性如果 onFulfilled 是函数： 当 promise 执行结束后其必须被调用，其第一个参数为 promise 的终值 在 promise 执行结束前其不可被调用 其调用次数不可超过一次 onRejected 特性如果 onRejected 是函数： 当 promise 被拒绝执行后其必须被调用，其第一个参数为 promise 的据因 在 promise 被拒绝执行前其不可被调用 其调用次数不可超过一次 调用时机onFulfilled 和 onRejected 只有在执行环境堆栈仅包含平台代码时才可被调用 调用要求onFulfilled 和 onRejected 必须被作为函数调用（即没有 this 值) 多次调用then 方法可以被同一个 promise 调用多次 当 promise 成功执行时，所有 onFulfilled 需按照其注册顺序依次回调 当 promise 被拒绝执行时，所有的 onRejected 需按照其注册顺序依次回调 返回then 方法必须返回一个 promise 对象 如果 onFulfilled 或者 onRejected 返回一个值 x，则运行下面的 Promise 解决过程：[Resolve] 如果 onFulfilled 或者 onRejected 抛出一个异常 e ，则 promise2 必须拒绝执行，并返回拒因 e 如果 onFulfilled 不是函数且 promise1 成功执行，promise2 必须成功执行并返回相同的值 如果 onRejected 不是函数且 promise1 拒绝执行， promise2 必须拒绝执行并返回相同的拒因 如何实现状态机 状态变迁仅支持两种状态变迁， fulfill 和 reject fulfill 和 reject 方法较为底层，通常更高级的 resolve 方法开放给外部。 resolve 方法可以接受一个普通值或者另一个 promise 作为参数，如果接受一个 promise 作为参数，等待其完成。 promise 不允许被另一个 promise fulfill ，所以需要开放 resolve 方法。 resolve 方法依赖一些帮助方法定义如下: 这里 resolve 和 doResolve 之间的递归很巧妙，用来处理 promise 的层层嵌套（ promise 的 value 是一个 promise ）。 构造器 .done 方法 .then 方法 参考资料 Node.js 最新技术栈之 Promise 篇 Promises&#x2F;A+ Promise 迷你书 "},{"title":"浅谈HTTP/2","date":"2018-05-09T04:09:43.000Z","url":"/2018/05/09/%E6%B5%85%E8%B0%88HTTP2/","tags":["WEB"],"content":"相信大家都或多或少听过 HTTP&#x2F;2 这个名词，听起来好像还很遥远，然而 Web 技术一直在突飞猛进，Google 在 16 年初放弃了对 SPYD 协议的支持，将相关服务切到了 HTTP&#x2F;2。浏览器方面，Chrome 40+ 和 Firefox 36+ 都正式支持了 HTTP&#x2F;2；服务器方面， Nginx 已经正式支持 HTTP&#x2F;2。 HTTP&#x2F;2 的由来SPDY 是 Google 开发的一个实验性协议，于 2009 年年中发布，其主要目标是通过解决 HTTP&#x2F;1.1 中广为人知的一些性能限制来减少网页的加载延迟。具体来说，这个项目设定的目标如下： 页面加载时间 (PLT) 减少 50%。 无需网站作者修改任何内容。 将部署复杂性降至最低，无需变更网络基础设施。 与开源社区合作开发这个新协议。 收集真实性能数据，验证这个实验性协议是否有效。 几年后的 2012 年，这个新的实验性协议得到了 Chrome、Firefox 和 Opera 的支持，越来越多的大型网站（如 Google、Twitter、Facebook）和小型网站开始在其基础设施内部署 SPDY。事实上，在被行业越来越多的采用之后，SPDY 已经具备了成为一个标准的条件。 观察到这一趋势后，HTTP 工作组 (HTTP-WG) 将这一工作提上议事日程，吸取 SPDY 的经验教训，并在此基础上制定了官方“HTTP&#x2F;2”标准。在拟定宣言草案、向社会征集 HTTP&#x2F;2 建议并经过内部讨论之后，HTTP-WG 决定将 SPDY 规范作为新 HTTP&#x2F;2 协议的基础。 那么为什么不叫 HTTP&#x2F;1.2 呢？为了实现 HTTP 工作组设定的性能目标，HTTP&#x2F;2 引入了一个新的二进制分帧层，该层无法与之前的 HTTP&#x2F;1.x 服务器和客户端向后兼容，因此协议的主版本提升到 HTTP&#x2F;2。 HTTP&#x2F;2 相比 HTTP&#x2F;1.x 的改进首部压缩每个 HTTP 传输都承载着说明传输资源及其属性的首部。在 HTTP&#x2F;1.x 中，这组元数据是纯文本的形式，通常会增加 500-800 字节的开销，使用 Cookie 的话开销则更大。而 HTTP&#x2F;2 使用了 HPACK 算法压缩了请求和响应头部元数据。 服务端推送HTTP&#x2F;2 服务器除了对最初请求的响应外，还可以向客户端推送额外资源而无需额客户端明确请求(Server Push)。如果主页向服务器发起一个请求，服务器可以响应主页内容、logo 以及样式表等，相当于在 HTML 文档内集合了所有资源，并且可以缓存。 多路复用HTTP&#x2F;1.x 中如果客户端想要发起多个并行的请求，那么得建立多个 TCP 连接，并且每个连接一次只交付一个响应，而多路复用允许同时通过单一的 HTTP&#x2F;2 连接发起多重的请求-响应消息。HTTP&#x2F;2 中客户端和服务器可以将 HTTP 消息分解为互不依赖的帧，然后交错发送，最后再在另一端把它们重新组装起来。 上图所示的是同一个连接内并行的多个数据流，客户端正在向服务器传输一个 DATA 帧（数据流 5），与此同时，服务器正向客户端交错发送数据流 1 和数据流 3 的一系列帧。因此，一个连接上同时有三个并行数据流。 HTTP&#x2F;2 的连接HTTP&#x2F;2 重新定义了格式化和传输数据的方式，这是通过在高层 HTTP API 和低层 TCP 连接之间引入二进制分帧层来实现的。HTTP&#x2F;1 的请求和响应报文，都是由起始行、首部和实体正文组成，各部分之间以文本换行符分隔。而 HTTP&#x2F;2 将请求和响应数据分割为更小的帧，并对它们采用二进制编码。下图中的 Binary Framing 即二进制分帧层。 其中有这么几个概念： 帧：HTTP&#x2F;2 数据通信的最小单位。帧用来承载特定类型的数据，如 HTTP 首部、负荷；或者用来实现特定功能，例如打开、关闭流。每个帧都包含帧首部，其中会标识出当前帧所属的流 消息：指 HTTP&#x2F;2 中逻辑上的 HTTP 消息。例如请求和响应等，消息由一个或多个帧组成 流：存在于连接中的一个虚拟通道。流可以承载双向消息，每个流都有一个唯一的整数 ID 连接：与 HTTP&#x2F;1 相同，都是指对应的 TCP 连接 在 HTTP&#x2F;2 中，同域名下所有通信都在单个连接上完成，这个连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。下图可以说明帧、消息、流和连接的关系。 带来的好处一个问题一个页面重要资源的加载速度对于用户体验是至关重要的，如果关键的 JS，顶部 CSS 加载缓慢，则会阻塞页面渲染或使用户无法交互。那么如何让重要的资源更快加载完呢？ HTTP&#x2F;1 的方案如果页面采用资源内联的方式，即 CSS、JS 直接内联在 HTML 中，虽然用户在第一次访问时有速度优势，但一般我们不会缓存 HTML 页面，这样的话内联资源没办法利用浏览器缓存，后面的每次访问都是一种浪费。 再来看看资源外链的情况。外链资源一般都会部署在 CDN 上，用户加载外链资源的时间，很大程序取决于请求发出的时间，主要受三个因素的影响： 浏览器阻塞：超过浏览器最大连接数限制时，后续请求就会被阻塞。而且现代浏览器在加载同一域名多个 HTTPS 资源时，会有意等第一个 TLS 连接建立完成再请求其他资源 DNS 查询：浏览器在建立连接前需要通过 DNS 将域名解析为 IP，第一次访问或者缓存失效时，会耗费几十到几百毫秒 建立连接：HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP 请求报文。这个过程通常也要耗费几百毫秒； 静态资源一般会被设置一个时间较长的缓存头，用户不清除浏览器缓存也不刷新时，第二次访问网页时静态资源会从本地缓存获取不产生网络请求。用户普通刷新时浏览器在请求头带上 If-Modified-Since 或 If-None-Match，服务端返回 304 告知浏览器从本地缓存中获取资源。所以资源外链首次慢，后面快。 既然资源内联和外链各有优劣，何不取长补短呢？我们可以对第一次访问的用户将资源内联，并在页面加载完之后异步加载这些资源的外链版本，同时记录一个 Cookie 标记表示用户来过。用户再次访问这个页面时，服务端就可以输出只有外链版本的页面，减小体积。 这样的话基本上能达到更快加载重要资源的效果了，但是这个方案也存在问题，一份资源内联外链加载了两次，会浪费流量，尤其是在流量宝贵的移动端会降低用户的体验。 HTTP&#x2F;2 的方案对于 HTTP&#x2F;2 来说，要解决前面这个问题就非常简单了，开启”Server Push”即可。HTTP&#x2F;2 的多路复用特性，使得可以在一个连接上同时打开多个流，双向传输数据。这样的话服务端可以在发送页面 HTML 时主动推送其它资源，而不用等到浏览器解析到相应位置，发起请求再响应。而且服务端主动推送的资源可以被浏览器缓存，也可以供其他页面使用。如果服务端推动的资源已经被缓存过的话，客户端也可以通过发送 RST_STREAM 帧来拒绝接收。 由此看来，HTTP&#x2F;2 的 Server Push 能够很好地解决”如何让重要资源尽快加载”这个问题，HTTP&#x2F;1 时代的优化方案在 HTTP&#x2F;2 普及之后应该会被逐渐取代。 最后看一个实例：HTTP&#x2F;2: the Future of the Internet 。同时请求 379 张图片，从 Load time 的对比可以看出 HTTP&#x2F;2 的速度以及性能优势。 参考资料 HTTP&#x2F;2 简介 HTTP&#x2F;2 新特性浅析 HTTP&#x2F;2: A New Excerpt from High Performance Browser Networking WEB 性能权威指南 HTTP&#x2F;2 与 WEB 性能优化 "},{"title":"CSS 3D Panorama及一些项目开发总结","date":"2017-11-07T04:09:43.000Z","url":"/2017/11/07/CSS%203D%20Panorama%E5%8F%8A%E4%B8%80%E4%BA%9B%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/","tags":["CSS3"],"content":"CSS3d项目涉及的技术主要是 CSS3d，3D 全景是其应用场景之一 优势：因为是基于 div+css3 实现,相对 canvas webgl 拥有更好的平台兼容性。 劣势：渲染性能相比 canvas webgl 要弱,只适合创建较小的三维面片场景。 渲染性能这点在项目完成后得到了证实 🤣，由于使用了大量 CSS3 Transform 相关的属性(一个页面内上百个元素)，包括 平移（translate）、旋转（rotate）、缩放（scale），导致在性能较差的移动设备上出现了卡顿和发热的情况。 transform 相关属性介绍： transform：修改 CSS 可视化模型的坐标空间，包括 平移（translate）、旋转（rotate）、缩放（scale） 和 扭曲（skew） perspective: 指定了观察者与 z&#x3D;0 平面的距离，使具有三维变换的元素产生透视效果 transform-style：为子元素提供 2D 还是 3D 的场景。另外，该属性是非继承的 transform-origin：允许被转换元素位置 实现 CSS3D 全景什么是全景？ 当你站在一个点，身体旋转 360°，这个过程看到的画面就是以你为中心的全景图了，焦距不变时等同于站在一个圆柱体的中心。 那么当我们有了全景图的素材后，将其切割为若干份，通过 transform 的平移和旋转将其拼为一个多棱柱，并通过 perspective 将视角置于棱柱中心(计算机世界是离散的，不能实现完美的圆柱，只能用近似圆柱的棱柱来代替)，就实现了全景效果。 未来城活动页是将全景图分割成 60 等份，相邻的元素构成夹角 6°(360&#x2F;60,相邻两侧面相对于棱柱中心所构成的夹角)。需要注意的是：我们要确保每个元素的正面是指向棱柱中心的。所以要计算好每等份的旋转角度值后，再将元素向外（即 Z 轴方向）平移 r px。对于立方体的 r 就是 边长&#x2F;2。 举个栗子：对于正九棱柱，每个元素的宽为 210px，对应的角度为 40°。 由此可得到一个公用函数，只需传入含有元素的宽度和元素数量的对象，即可得到 r 值： 设置视角正棱柱构建完成后，需要将我们的视角设置在正棱柱内，超过视角外的元素不会被浏览器渲染(translateZ &gt; perspective)，并且保证棱柱的正面都是指向正棱柱中心，就可以形成 360° 的环绕效果了。 只要保证.div 元素自身 Z 坐标和祖先元素 Z 坐标相加大于 #view 元素的 perspective 值即可。 对于全景图素材的要求 水平方向上需要首尾相连 因为效果图最终需要切成 N 等份，所以尽可能让 设计图的宽度能被 N 整除 图片尺寸不仅要考虑正视图的大小，还要考虑元素在上下旋转时依然能覆盖视野 参考资料 前端的 3D(css3 版本)–淘宝造物节 3D 创景的制作 CSS 3D Panorama - 淘宝造物节技术剖析 另外项目中使用了一个小巧实用的辅助支持库,对相关元素及方法进行了封装：css3d-engine "},{"title":"总结及规划","date":"2017-11-02T04:09:43.000Z","url":"/2017/11/02/%E6%80%BB%E7%BB%93%E5%8F%8A%E8%A7%84%E5%88%92/","tags":["thinking"],"content":"以怎样的标准来要求自己、提升自己？ 技术准备 补齐基础知识 单点深挖 大公司推崇一专多长 百度某总监： 大学的时候以广度为主，拓展视野 工作之后以深度为主，单点深挖 当达到瓶颈后，再次向广度拓展，打通知识 以技术项目练兵 挖掘技术项目：从业务优化出发 挖掘技术项目：以好玩有趣为主 写文、分享 思想准备 沟通能力 沟通要领 用沟通代替自作主张 多做反馈，主动反馈 有风险及时抛出 正视资源不足 “如果什么都准备好了，那这个事情谁都能做，公司还要花高工资招你干嘛？” 问题到我为止 当产品让你看一个现网问题 “这不是前端问题，你问下后台同学” “我和后台某某同学对过，是他们那边 xxx 引起的问题。我们讨论后，有 xxx 和 xxx 两种方案，打算采用 xxx 方案，解决更彻底，预计 xxx 完成。虽然不是前端问题，但前端这边也打算做 xxx 的兼容优化，保证出问题时不影响体验，明天完成……” 培养高效工作方法 找到适合自己的工作方法 最后，乐观自信和技术能力一样重要"}]